:toc:
:toc-title: ОГЛАВЛЕНИЕ
:figure-caption: Рисунок

[.text-center]

= Лабораторная работа №6

[.text-center]

Отладочная плата. Порты и таймеры

[.text-center]

Автор: Володина Екатерина 

[.text-center]

Группа: КЭ-413

<<<


[.text-left]

== ВВЕДЕНИЕ

Микроконтроллер STM32F411 широко применяется в электронных устройствах управления. Для его изучения используется отладочная плата, позволяющая на практике работать с аппаратными ресурсами микроконтроллера.

В данной работе рассматриваются порты ввода-вывода и таймеры, которые используются для подключения внешних устройств и отсчёта времени. 

Цель работы: переключиться на частоту 32 МГц и провести настройку таймера 2.


<<<

[.text-left]

== Отладочная плата

[cols="a, a"]
|===
| * *STM32F411RET6 ядро:* ARM® 32-bit Cortex™-M4 |  * *CP2102:* USB - UART преобразователь
| * *Arduino разъем:* для подключения Arduino шилдов ​| * *ICSP interface:* Arduino ICSP
| * *USB разъем:* USB коммуникационный интерфейс| * *SWD interface:* для программирования и отладки
| * *ST Morpho разъемы:*  для упрощения расширения​| * ​*6-12 V DC вход питания*
| * *Пользовательская кнопка* | * *Кнопка Сброса*
| * *Индикатор питания* | * *Пользовательские светодиоды*
| * *Индикаторы последовательного порта Rx/Tx* ​| *8 MHz кварцевый резонатор*
|===

<<<

[.text-left]

== Микроконтроллер ST32F411RE

Микроконтроллер STM32F411RE построен на базе высокопроизводительного ядра *ARM Cortex-M4*. Относится к линейке микроконтроллеров общего назначения с балансом производительности и энергоэффективности.

=== Особенности 

* *Ядро:* ARM Cortex-M4 с FPU (частота до 100 МГц);

* *Память:* 512 КБ Flash, 128 КБ SRAM;

* *Энергопотребление:* ~100 мкА/МГц (при питании 1.7-3.6 В);

* *Периферия:* USB 2.0, 3x USART, 5x SPI/I2S, 3x I2C, SDIO, 12-битный АЦП;

* *Таймеры:*  различного назначения.

=== Ядро Cortex-M4

* Ядро Cortex построено по гарвардской архитектуре с разделением шины данных и кода.

* Ядро Cortex-M4 поддерживает 8/16/32-разрядные операции умножения, которые выполняются за 1 цикл (деление со знаком (SDIV) или без знака (UDIV) занимает от 2 до 12 тактов в зависимости от размера операндов​

* Ядро Cortex-M4 поддерживает 8/16/32-разрядные операции умножения со сложением.

=== Блок-схема микроконтроллера

изображена на рисунке 1.

.Блок-схема микроконтроллера
image::blok-shema6.png[800, 800]


*Дополнительные особенности микроконтроллера*

Из дополнительных навыков, которые понадобятся для лабораторных работ, следует выделить:

* Настраиваемые источники тактовой частоты;

* Настраиваемые порты для различных функций;

* Внутренний датчик температуры;

* Таймеры с настраиваемым модулем ШИМ;

* DMA для работы с модулями (SPI, UART, АЦП и т. д.);

* 12-разрядный АЦП последовательного приближения;

* Часы реального времени;

* Системный таймер и специальные прерывания для упрощения и ускорения работы ОСРВ.

=== Система тактирования
.Система тактирования
image::sistema-taktirovania.png[800, 800]

* Для формирования системной тактовой частоты SYSCLK могут использоваться 4 основных источника:

** HSI (высокоскоростной внутренний) — внутренний высокочастотный RC-генератор;

** HSE (высокоскоростной внешний) — внешний высокочастотный генератор;

** PLL — система фазовой автоподстройки частоты. Точнее, это вовсе не генератор, а набор умножителей и делителей. Исходный сигнал он получает от HSI или HSE, а на выходе у него уже другая частота.

* Также имеются 2 вторичных источника тактового сигнала:

** LSI (low-speed internal) — низкочастотный внутренний RC-генератор на 37 кГц​;

** LSE (low-speed external) — низкочастотный внешний источник на 32 768 кГц​.


=== Фазовая подстройка частоты PLL
* PLL ​Внутренний источник PLL тактируется от внешнего или внутреннего высокочастотных генераторов (HSE либо HSI). ​
** С помощью регистров PLLM, PLLN,PLLP можно подобрать любую частоту до 100 Мгц включительно по формуле:​
====
   f = f(PLL clock input) × (PLLN / PLLM) /PLLP​
====
** Кроме системной тактовой частоты SYSCLK, PLL также выдает частоту 48 МГц для интерфейса USB.
  При использовании USB входная частота для PLL должна быть в диапазоне от 2 МГц до 24 МГц.​
====
   f(USB) = f(PLL clock input) × (PLLN / PLLM) / PLLQ​
====

<<<

[.text-left]

== Порты общего назначения

=== Основные характеристики

* 5 портов общего назначения​

* 16 линий ввода-вывода​

* Режимы ввода:

** цифровой с подтяжкой к 1 и 0

** аналоговый​

* Возможность работы в альтернативном режиме

*Различные режимы работы портов*

* Плавющий цифровой вход (Input floating)

* Цифровой вход с подтяжкой к 1 (Input pull-up)

* Цифровой вход с подтяжкой к 0 (Input-pull-down)

* Аналоговый (Analog)​

* Цифровой выход с открытым коллектором с подтяжкой к 1 или к 0 (Output open-drain with pull-up or pull-down capability)

* Цифровой двухтактный выход с подтяжкой к 1 или к 0 (Output push-pull with pull-up or pull-down capability) ​

* Альтернативная функция с открытым коллектором с подтяжкой к 1 или к 0 (​Alternate function push-pull with pull-up or pull-down capability)

* Альтернативная функция двухтактный выход с подтяжкой к 1 или к 0 ()​Alternate function open-drain with pull-up or pull-down capability)

=== Регистры портов общего назначения​

* GPIOx_MODER (регистр режима порта). Задает режимы работы для каждого вывода порта. ​

** Каждый из выводов GPIO может быть настроен как вход, выход, работать в аналоговом режиме или быть подключённым к одной из альтернативных функций.

* GPIOx_OSPEEDR (регистр скорости вывода порта). Задает скорость работы порта: ​

** 400 кГц, 2 МГц, 10 МГц и 40 МГц.

* GPIOx_PUPDR (регистр подтягивания/отпускания порта). Задает подключение подтягивающих резисторов

** Без подтягивающего резистора, с подтяжкой к «+» питания, с подтяжкой к «земле».

* GPIOx_IDR (регистр входных данных). регистр входных данных, из которого считывается состояние входов порта.​

* GPIOx_ODR (регистр выходных данных). регистр выходных данных. Запись числа в младшие 16 бит приводит к появлению соответствующих уровней на выводах порта.​

* GPIOx_OTYPER (регистр типа выхода порта). В режиме выхода или альтернативной функции соответствующий бит регистра устанавливает тип выхода. ​

** Push-Pull (двухтактный) или Open Drain (выход с открытым коллектором).

* GPIOx_BSRR (регистр установки/сброса битов порта). Это регистр побитовой установки/сброса данных на выходных линиях порта.

<<<

[.text-left]

== Таймеры

Одна из основных задач таймеров в микроконтроллерах — отсчёт точных интервалов времени. Но помимо этого таймеры могут использоваться для измерения частоты, периодов, генерации ШИМ и переменных сигналов различной формы.

[horizontal]

TIM9-TIM11:: Самые простые 16 битные таймеры.
TIM2-TIM5:: Таймеры общего назначания. (TIM2 и TIM5 32 битные) (TIM3 и TIM4 16 битные)
TIM1:: Расширенный 16 битный таймер

SYSTEM TIMER:: Также существуют системный таймер *SysTick* таймер и Watchdog таймер.

[.notes]

=== Системный таймер

Самый простой таймер, встроенный в ядро ARMv7, на котором построено ядро CortexM4 и наш микроконтроллер stm32F411, то есть его поддерживают все микроконтроллеры на этом ядре.

* 24-битный таймер, отсчитывающий время от заданного значения до нуля.

=== Таймеры TIM2 и TIM5, основные характеристики

* Таймеры 32-битные (то есть могут считать до 2^32), умеют работать:

** с инкрементальными энкодерами и датчиками Холла,

** несколько таймеров можно синхронизировать между собой.

* Таймеры можно использовать для:

** Захват сигнала (защелкивание значения, когда на выводе порта, например, 0 меняется на 1)

** Сравнение (считывание значения в регистре сравнения и установка/сброс/переключение вывода порта)

** Генерация ШИМ (генерация прямоугольного сигнала с различной скважностью на выводе порта)

** Генерация одиночного импульса

=== Таймеры TIM2 и TIM5

* Таймеры могут генерировать следующие события:

** Переполнение

** Захват сигнала

** Сравнение

** Триггер события

<<<

[.text-left]

== Практическая часть 

=== Источник частоты

Модуль тактирования состоит из 5 видов источников тактирования:

1. 2 основных и 1 производный. Они отвечают за формирование системной тактовой частоты SYSCLK:

* HSI (high-speed internal) - внутренний высокочастотный; 
* HSE (high-speed external) - внешний высокочастотный; 
* PLL (phase-locked loop) - фазовая автоподстройка частоты, ФАПЧ. 

2. и 2 вторичных:

* LSI (low-speed internal) - внутренний низкочастотный; 
* LSE (low-speed external) - внешний низкочастотный.

От LSE с частотой 32.768 кГц можно создать часы.

ФАПЧ (PLL) не самостоятельный источник, а является лишь системой из умножителей и делителей, модифицирущих HSE и HSI сигналы (рисунок 1).

*Настройка:*

Настройка первичных источников тактирования затрагивает 3 основных регистра: 

* RCC_CR; 
* RCC_CFGR;
* RCC_PPLLCFGR.

Включение источников тактирования выполняется через регистр *CR* (Clock Control register). В этом же регистре располагаются биты проверки работы источников, т.е. существует задержка между командой "включить" и ответом "включен" от системы.

Контроль работы

|===
||PLL|HSE|HSI
|RDY|Bit [25]|Bit [17]|Bit [1]
|ON|Bit [24]|Bit [16]|Bit [0]
|===

Чтобы включить источник, следует установить 1 в бит ON. Чтобы выключить -- 0.

Дальнейшие действия могут происходить только после того как в бит _RDY_ аппаратно установился бит 1. Иначе источник не готов к работе (стоит 0).

Затем идет переключение работы системной частоты SYSCLK с одного источника на другой. Это делается через регистр *CFGR*.

*SW* отвечает за выбор источника (программно);

*SWS* отвечает за подтверждение переключения на нужный источник (устанавливается аппаратно).

Допустимые значения для этих полей:

* 00 -- включен HSI
* 01 -- включен HSE
* 10 -- включен PLL

Так же, как и при включении источников, для дальнейшей работы требуется сначала проверить установлен ли SWS в тот же режим, что и SW.

Для настройки делителей/умножителей PLL существует отдельный регистр PLLCFGR. Его следует настроить в первую очередь перед запуском PLL.

Можно подобрать почти любую частоту до 100 МГц, подбирая и записывая значения делителей/умножителей по следующей формуле:

====
f = f(PLL clock input) × (PLLN / PLLM) /PLLP​
====

Мы аккуратно подбираем эти значения, т.к. в документации на микроконтроллер есть ограничения на сами коэффициенты и на некоторые промежуточные значения (например, N от 50 до 432; M от 2 до 63; P: 2, 4, 6, 8 и тд.).

*Настройка HSE*

[source, cpp]
----
  RCC::CR::HSEON::On::Set(); // <1>
  while (RCC::CR::HSERDY::NotReady::IsSet()) // <2> 
  {

  }
  RCC::CFGR::SW::Hse::Set(); //<3>
  while (!RCC::CFGR::SWS::Hse::IsSet())//<4>
  {

  }
  RCC::CR::HSION::Off::Set(); //<5> 
----

<1> включили
<2> проверили включение
<3> перекинули ключ SW на HSE
<4> проверили, что ключ переключился
<5> отключили HSI

*Настройка PLL на 36 МГц на основе HSE*

[source, cpp]
----
  RCC::PLLCFGR::PLLSRC::HseSource::Set(); //1
  
  RCC::PLLCFGR::PLLN0::Set(64); // n = 64
  RCC::PLLCFGR::PLLP0::Set(3); // p = 8
  RCC::PLLCFGR::FieldValues::Set(2); // m = 2
  //2
 RCC::CR::PLLON::On::Set(); //3
  while (RCC::CR::PLLRDY::Unclocked::IsSet()) //4
  {

  }
  RCC::CFGR::SW::Pll::Set(); //5
  while (!RCC::CFGR::SWS::Pll::IsSet()) //6
  {

  }
----

1. настроили источник ФАПЧ на HSE
2. определили коэффициенты 
3. включили
4. проверили, что включили
5. перевели SW на PLL
6. проверили, что перевели

=== Таймеры

*Настройки системного таймера*

[source, cpp]
----
#include "stkregisters.h" // для системного таймера

std::uint32_t SystemCoreClock = 16000000U;
std::uint32_t ticks = SystemCoreClock/1000U-1U; // 1
extern "C" {
int __low_level_init(void)
{
  STK::LOAD::RELOAD::Set(ticks); // 2
  STK::VAL::Write(0); //3
  STK::CTRL::CLKSOURCE::Set(0); //4
  STK::CTRL::ENABLE::Enable::Set(); // 5
  
  RCC::APB2ENR::SYSCFGEN::Enable::Set();

  return 1;
}
}
////////////////////////////////////////
int main()
{ 
  /////////////////////////////////////
  for(;;)
  {   
    if (userButton.WasPressed())
    {
      modeController.SwitchMode(); 
    }
    if (STK::CTRL::COUNTFLAG::Overflow::IsSet()) // 6
    {
      modeController.RunCurrentMode(); 
    }
  }
  return 1;
}
----

1. Определяем задержку
2. Устанавливаем задержку на 1 мс
3. Сбрасываем текущее значение
4. Устанавливаем HSI как источник тактирования (он и по умолчанию 0, но для наглядности)
5. Включаем
6. Проверяем флаг на переполнение

*Таймер TIM2*

32-битный таймер общего назначения (как и TIM5).

Всего 5 регистров, им управляющих:

* PSC - длитель частоты. Позволяет счетчику переполняться медленнее.
* ARR - autoreload register. Позволяет задать произвольное время переполнения таймера.
* СNT - регистр, хранящий текущее значение счетчика.
* SR::UIF - регистр, хранящий бит флага вызова прерывания (например, переполнение или обнуление).
* CR1::CEN - регистр, хранящий бит включения/выключения таймера.


*Настройки таймера TIM2*

[source, cpp]
----
#include "tim2registers.hpp" // for tim2

extern "C" {
int __low_level_init(void)
{
  RCC::APB1ENR::TIM2EN::Enable::Set(); // подаем тактирование
  TIM2::PSC::Set(0); // устанавливаем делитель частоты в 0
  TIM2::ARR::Write(99'999); // записываем значение для задержки в 1 мс
  TIM2::SR::UIF::Set(0); // сбрасываем флаг генерации прерывания
  TIM2::CNT::Set(0); // сбрасываем счетчик в 0
  TIM2::CR1::CEN::Set(1); // запускаем таймер

  RCC::APB2ENR::SYSCFGEN::Enable::Set();

  return 1;
}
}
////////////////////////////////////
int main()
{ 
 /////////////////////////////////
  
  for(;;)
  { 
    if (userButton.WasPressed())
    {
      modeController.SwitchMode(); 
    }
    if (TIM2::SR::UIF::InterruptPending::IsSet()) // если пришло прерывание
    {
      TIM2::CR1::CEN::Set(0); //останавливаем таймер
      TIM2::SR::UIF::Set(0); // сбрасываем флаг прерывания
      TIM2::CNT::Set(0); // устанавливаем счетчик в 0
      modeController.RunCurrentMode();
      TIM2::CR1::CEN::Set(1); //снова включаем таймер
    }
  }
  return 1;
}
----

*Настройка портов*

[source, cpp]
----
int main()
{ 
  //Подать тактирование на порт А
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  //Порта А.5 на вывод
  GPIOA::MODER::MODER5::Output::Set() ;
}  
----

<<<

[.text-left]

== ЗАКЛЮЧЕНИЕ

В ходе работы были рассмотрены порты ввода-вывода, таймеры и источники тактирования микроконтроллера, а также принципы их работы и настройки. Отдельное внимание было уделено системному таймеру и 32-битным таймерам общего назначения.

Также было замечено, что при работе с таймерами кнопка может срабатывать несколько раз вместо одного. Это связано с прерываниями и эффектом дребезга контактов, из-за чего микроконтроллер воспринимает одно нажатие как несколько.

<<<

[.text-left]